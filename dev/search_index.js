var documenterSearchIndex = {"docs":
[{"location":"license/","page":"LICENSE","title":"LICENSE","text":"MIT License","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"Copyright (c) 2021 QuantEx team","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"LabeledGraph/#Labeled-Graphs","page":"Labeled Graphs","title":"Labeled Graphs","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"QXGraphs uses the SimpleGraph struct from the LightGraphs package to store graph structures.  However, some of the algorithms implemented in QXGraphs repeatedly modify the graph they work  on, either by removing or adding vertices in varying orders, and in turn alter the manner in  which vertices in the graph are indexed. This can make it difficult to track where vertices end up in a graph after many modifications are made, which needs to be done if the vertices are used to index different variables in an alternate data structure, such as indices or  tensors in a tensor network. To this end, QXGraphs defines a LabeledGraph struct which pairs a SimpleGraph with and array of julia symbols which can be used to identify vertices in a graph after modifications have been made. ","category":"page"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"LabeledGraph","category":"page"},{"location":"LabeledGraph/#QXGraphs.LabeledGraph","page":"Labeled Graphs","title":"QXGraphs.LabeledGraph","text":"Struct to represent a labeled graph. Unique symbols are created for each vertex if none are provided and remain unaltered during the lifetime of the graph.\n\nExample\n\njulia> g = LabeledGraph()\nLabeledGraph({0, 0} undirected simple Int64 graph, Symbol[])\n\njulia> add_vertex!(g, :a_vertex_label)\n1-element Array{Symbol,1}:\n :a_vertex_label\n\njulia> g.labels[1]\n:a_vertex_label\n\n\n\n\n\n","category":"type"},{"location":"LabeledGraph/#Example-usage","page":"Labeled Graphs","title":"Example usage","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"An example of how to use LabeledGraphs is shown below. Note, whenever a modification is made to the graph which re-indexes or re-positions the vertices in the graph, the array of vertex  labels in the LabeledGraph is also updated to reflect the reordering. Hence, when a sequence of modifications is made to the graph, we can identify how the vertices of the original  graph are now indexed in the new graph by looking at how the corresponding labels are  indexed inside the LabeledGraph.","category":"page"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"using QXGraphs\n\n# Create a LabeledGraph with N vertices\nN = 10\nG = LabeledGraph(N)\n\n# Display the label assigned to the first and last vertices in the graph.\n@show G.labels[1]\n@show G.labels[end]\n\n# Remove the first vertex in the graph. To remove a vertex, LightGraphs first swaps the \n# positions of the vertex being removed and the last vertex and then removes the last vertex.\nrem_vertex!(G, 1)\n\n# Display the label which is now assigned to the first vertex in the graph.\n@show G.labels[1]","category":"page"},{"location":"LabeledGraph/#LabeledGraph-Interface","page":"Labeled Graphs","title":"LabeledGraph Interface","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"The interface for the LabeledGraph struct is intended to reflect the interface implemented  by the LightGraphs package for the SimpleGraph struct.","category":"page"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"get_vertex\nvertices\nnv\nadd_vertex!\nrem_vertex!\nedges\nne\nadd_edge!\nhas_edge\nrem_edge!\ndegree\nall_neighbors\neliminate!","category":"page"},{"location":"LabeledGraph/#QXGraphs.get_vertex","page":"Labeled Graphs","title":"QXGraphs.get_vertex","text":"get_vertex(G::LabledGraph, v_label)\n\nReturn the first vertex whose label matches the argument v_label. If an array of labels is provided, an array of the corresponding vertices is return. \n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.vertices","page":"Labeled Graphs","title":"QXGraphs.vertices","text":"vertices(G::LabeledGraph)\n\nReturn the vertices of a labeled graph.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.nv","page":"Labeled Graphs","title":"QXGraphs.nv","text":"nv(G::LabeledGraph)\n\nReturn the number of vertices in G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.add_vertex!","page":"Labeled Graphs","title":"QXGraphs.add_vertex!","text":"add_vertex!(G::LabeledGraph, label::Symbol)\n\nAdd a new vertex to G and assign the given label to it.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.rem_vertex!","page":"Labeled Graphs","title":"QXGraphs.rem_vertex!","text":"rem_vertex!(G::LabeledGraph, v)\n\nDelete the vertex with index or label v from G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.edges","page":"Labeled Graphs","title":"QXGraphs.edges","text":"edges(G::LabeledGraph)\n\nReturn an iterator of the edges of G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.ne","page":"Labeled Graphs","title":"QXGraphs.ne","text":"ne(G::LabeledGraph)\n\nReturn the number of edges in G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.add_edge!","page":"Labeled Graphs","title":"QXGraphs.add_edge!","text":"add_edge!(G::LabeledGraph, u::Int, v::Int)\n\nAdd an edge to G connecting vertices u and v.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.has_edge","page":"Labeled Graphs","title":"QXGraphs.has_edge","text":"has_edge(G::LabeledGraph, u::Int, v::Int)\n\nReturn true if G has an edge connecting vertices u and v. Return false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.rem_edge!","page":"Labeled Graphs","title":"QXGraphs.rem_edge!","text":"rem_edge!(G::LabeledGraph, u::Int, v::Int)\n\nRemove the edge connecting vertices u and v if it exists.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.degree","page":"Labeled Graphs","title":"QXGraphs.degree","text":"degree(G::LabeledGraph[, v])\n\nReturn an array containing the degree of each vertex of G. If v is specified, only  return degrees for vertices in v.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.all_neighbors","page":"Labeled Graphs","title":"QXGraphs.all_neighbors","text":"all_neighbors(G::LabeledGraph, v::Int)\n\nReturn an array of all neighbors of v in G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.eliminate!","page":"Labeled Graphs","title":"QXGraphs.eliminate!","text":"eliminate!(G::LabledGraph, v)\n\nConnect all the neighbors of v together before removing v from G.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#Line-Graph","page":"Labeled Graphs","title":"Line Graph","text":"","category":"section"},{"location":"LabeledGraph/","page":"Labeled Graphs","title":"Labeled Graphs","text":"line_graph\ncombine_labels","category":"page"},{"location":"LabeledGraph/#QXGraphs.line_graph","page":"Labeled Graphs","title":"QXGraphs.line_graph","text":"line_graph(G)\n\nReturn a LabeledGraph representing the line graph of the 'G'. \n\nIf 'G' is a LabeledGraph then a label for each each vertex of the line graph is created by  concatenating the labels of the corresponding vertices in 'G'. Otherwise, labels are  created by combining the indices of those vertices in 'G'.\n\n\n\n\n\n","category":"function"},{"location":"LabeledGraph/#QXGraphs.combine_labels","page":"Labeled Graphs","title":"QXGraphs.combine_labels","text":"combine_labels(label_A, label_B)\n\nConcatenate 'labelA' and 'labelB' in lexicographical order. \n\n\n\n\n\n","category":"function"},{"location":"docs_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docs_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"treewidth/#Treewidth-Algorithms","page":"Treewidth","title":"Treewidth Algorithms","text":"","category":"section"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"One strategy for building contraction plans for tensor networks involves finding a vertex  elimination order for the network's line graph. The treewidth of a graph, with respect to a vertex elimination order, is the maximum number of neighbours a vertex has in the graph when it is eliminated according the order. In the context of tensor network contraction,  treewidth serves as an indirect measure of the size of the largest intermediate tensor  produced while contracting a network according to a the contraction plan built from the elimination order. It is thus also an indirect measure of the computational cost of  contracting a tensor network according to the corresponding contraction plan. QXGraphs  provides functions for finding such elimination orders with minimal treewidth.","category":"page"},{"location":"treewidth/#Vertex-Elimination-Orders","page":"Treewidth","title":"Vertex Elimination Orders","text":"","category":"section"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"A standard algorithm for finding elimination orders, whose treewidth provides a good upper bound for the minimal treewidth of a graph, is known as the QuickBB algorithm. It was first proposed by Vibhav Gogate and Rina Dechter in their 2004 paper \"A complete  Anytime Algorithm for Treewidth\". The paper along with a binary implementation of the  algorithm is provided here. QXGraphs provides a julia wrapper for their binary which requires a linux OS.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"quickbb\ngraph_to_cnf","category":"page"},{"location":"treewidth/#QXGraphs.quickbb","page":"Treewidth","title":"QXGraphs.quickbb","text":"quickbb(G::lg.AbstractGraph; \n        time::Integer=0, \n        order::Symbol=:_, \n        verbose::Bool=false )::Tuple{Int, Array{Int, 1}}\n\nCall Gogate's QuickBB binary on the provided graph and return the resulting perfect  elimination ordering. \n\nA dictionary containing metadata for the elimination order is also returned. Metadata includes: \n\n:treewidth of the elimination order,  \n:time taken by quickbb to find the order,\n:lowerbound for the treewidth computed by quickbb,\n:is_optimal a boolean indicating if the order as optiaml treewidth.\n\nThe QuickBB algorithm is described in arXiv:1207.4109v1\n\nKeywords\n\ntime::Integer=0: the number of second to run the quickbb binary for.\norder::Symbol=:_: the branching order to be used by quickbb (:random or :min_fill).\nlb::Bool=false: set if a lowerbound for the treewidth should be computed.\nverbose::Bool=false: set to true to print quickbb stdout and stderr output.\nproc_id::Integer=0: used to create uniques names of files for different processes.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/#QXGraphs.graph_to_cnf","page":"Treewidth","title":"QXGraphs.graph_to_cnf","text":"graph_to_cnf(G::lg.AbstractGraph, filename::String)\n\nWrite the provided graph to a cnf file for Gogate's QuickBB binary.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/#Partial-Elimination-order","page":"Treewidth","title":"Partial Elimination order","text":"","category":"section"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"The following functions can be used to create an elimination order for a graph G with a  specified clique of G appearing at the end of the order. This is useful for finding contraction plans for tensor networks containing open indices. The algorithm and application of these functions is described further by Shutski et al in  this paper.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"build_chordal_graph\nrestricted_mcs","category":"page"},{"location":"treewidth/#QXGraphs.build_chordal_graph","page":"Treewidth","title":"QXGraphs.build_chordal_graph","text":"build_chordal_graph(G::LabeledGraph, π̄::Array{Symbol, 1})\n\nReturn a chordal graph built from 'G' using the elimination order 'π̄'.\n\nThe returned graph is created from 'G' by iterating over the vertices of 'G', according to  the order 'π̄', and for each vertex, connecting all the neighbors that appear later in the  order.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/#QXGraphs.restricted_mcs","page":"Treewidth","title":"QXGraphs.restricted_mcs","text":"restricted_mcs(H::LabeledGraph, C::Array{Symbol, 1})\n\nReturn an elimination order for 'H' with the vertices in 'C' appearing at the end.\n\nThe algorithm is described by Shutski et al in https://arxiv.org/abs/1911.12242\n\n\n\n\n\n","category":"function"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"Given an elimination order pi for a particualr graph G, the treewidth of G with  respect to the order pi can be computed using the following function.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"find_treewidth_from_order","category":"page"},{"location":"treewidth/#QXGraphs.find_treewidth_from_order","page":"Treewidth","title":"QXGraphs.find_treewidth_from_order","text":"find_treewidth_from_order(G::LabeledGraph, π̄::Array{Symbol, 1})\n\nReturn the treewidth of G with respect to the elimination order π̄.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/#Treewidth-deletion","page":"Treewidth","title":"Treewidth deletion","text":"","category":"section"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"The problem of finding a select number of vertices in a graph to delete, in order to reduce the treewidth of the graph, is known as the treewidth deletion problem. A method for  solving this problem, implemented by the functions below, and it's application to tensor  network slicing is discussed by Shutski et al here.","category":"page"},{"location":"treewidth/","page":"Treewidth","title":"Treewidth","text":"greedy_treewidth_deletion\ndirect_treewidth_score","category":"page"},{"location":"treewidth/#QXGraphs.greedy_treewidth_deletion","page":"Treewidth","title":"QXGraphs.greedy_treewidth_deletion","text":"greedy_treewidth_deletion(G::LabeledGraph, m::Int=4;\n                          score_function::Symbol=:degree, \n                          π::Array{Symbol, 1}=[])\n\nGreedily remove vertices from G with respect to minimising the chosen score function. Return the reduced graph and an array of vertices which were removed.\n\nThe intermediate elimination orders and corresponding treewidths of the intermediate graphs are also returned if an elimination order for G is provided.\n\nThe algorithm is described by Schutski et al in Phys. Rev. A 102, 062614.\n\nKeywords\n\nscore_function::Symbol=:degree: function to maximise when selecting vertices to remove.                                   (:degree, :direct_treewidth)\nelim_order:Array{Symbol, 1}=Symbol[]: The elimination order for G to be used by                                          direct_treewidth score function.\n\n\n\n\n\n","category":"function"},{"location":"treewidth/#QXGraphs.direct_treewidth_score","page":"Treewidth","title":"QXGraphs.direct_treewidth_score","text":"direct_treewidth_score(G::LabeledGraph, π::Array{Symbol, 1})\n\nReturn an array of integers, one for each vertex in G, indicating the change in treewidth of G, with respect to π, if that vertex is removed.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QXGraphs","category":"page"},{"location":"#QXGraphs","page":"Home","title":"QXGraphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QXGraphs is a Julia package for analysing and manipulating graph structures describing tensor  networks in the QuantEx project. It provides functions for solving graph theoretic problems  related to the task of efficiently slicing and contracting a tensor network.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QXGraphs was developed as part of the QuantEx project, one of the individual software  projects of WP8 of PRACE 6IP.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QXGraphs is a Julia package and can be installed using Julia's inbuilt package manager from  the Julia REPL using.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"QXGraphs\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure everything is working, the unittests can be run using","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.test()","category":"page"},{"location":"#Example-usage","page":"Home","title":"Example usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An example of how QXGraphs can be used to calculate a vertex elimination order for a graph looks like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QXGraphs\n\n# Create a LabeledGraph with N fully connected vertices.\nN = 10\nG = LabeledGraph(N)\nfor i = 1:N, j = i+1:N\n    add_edge!(G, i, j)\nend\n\n# To get an elimination order for G with minimal treewidth we call quickbb.\nelimination_order, md = quickbb(G)\n@show elimination_order\n\n# The treewidth of the elimination order is contained in the metadata dictionary returned by quickbb.\n@show md[:treewidth]","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information about the algorithms made available by QXGraphs please consult the contents below.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Treewidth Algorithms Describes useful algorithms for analysing a tensor network's line graph.\nLabeled Graphs Describes the QXGraphs LabeledGraph struct for representing graphs.","category":"page"}]
}
