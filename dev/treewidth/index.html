<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Treewidth · QXGraph.jl</title><link rel="canonical" href="https://JuliaQX.github.io/QXGraph.jl/treewidth/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="QXGraph.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">QXGraph.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../LabeledGraph/">Labeled Graphs</a></li><li class="is-active"><a class="tocitem" href>Treewidth</a><ul class="internal"><li><a class="tocitem" href="#Vertex-Elimination-Orders"><span>Vertex Elimination Orders</span></a></li><li><a class="tocitem" href="#Treewidth-deletion"><span>Treewidth deletion</span></a></li></ul></li><li><a class="tocitem" href="../docs_index/">Index</a></li><li><a class="tocitem" href="../license/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Treewidth</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Treewidth</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQX/QXGraph.jl/blob/master/docs/src/treewidth.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Treewidth-Algorithms"><a class="docs-heading-anchor" href="#Treewidth-Algorithms">Treewidth Algorithms</a><a id="Treewidth-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Treewidth-Algorithms" title="Permalink"></a></h1><p>One strategy for building contraction plans for tensor networks involves finding a vertex  elimination order for the network&#39;s line graph. The treewidth of a graph, with respect to a vertex elimination order, is the maximum number of neighbours a vertex has in the graph when it is eliminated according the order. In the context of tensor network contraction,  treewidth serves as an indirect measure of the size of the largest intermediate tensor  produced while contracting a network according to a the contraction plan built from the elimination order. It is thus also an indirect measure of the computational cost of  contracting a tensor network according to the corresponding contraction plan. QXGraph  provides functions for finding such elimination orders with minimal treewidth.</p><h2 id="Vertex-Elimination-Orders"><a class="docs-heading-anchor" href="#Vertex-Elimination-Orders">Vertex Elimination Orders</a><a id="Vertex-Elimination-Orders-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex-Elimination-Orders" title="Permalink"></a></h2><p>A standard algorithm for finding elimination orders, whose treewidth provides a good upper bound for the minimal treewidth of a graph, is known as the QuickBB algorithm. It was first proposed by Vibhav Gogate and Rina Dechter in their 2004 paper &quot;A complete  Anytime Algorithm for Treewidth&quot;. The paper along with a binary implementation of the  algorithm is provided <a href="http://www.hlt.utdallas.edu/~vgogate/quickbb.html">here</a>. QXGraph provides a julia wrapper for their binary which requires a linux OS.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraph.quickbb" href="#QXGraph.quickbb"><code>QXGraph.quickbb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quickbb(G::lg.AbstractGraph; 
        time::Integer=0, 
        order::Symbol=:_, 
        verbose::Bool=false )::Tuple{Int, Array{Int, 1}}</code></pre><p>Call Gogate&#39;s QuickBB binary on the provided graph and return the resulting perfect  elimination ordering. </p><p>A dictionary containing metadata for the elimination order is also returned. Metadata includes: </p><ul><li><code>:treewidth</code> of the elimination order,  </li><li><code>:time</code> taken by quickbb to find the order,</li><li><code>:lowerbound</code> for the treewidth computed by quickbb,</li><li><code>:is_optimal</code> a boolean indicating if the order as optiaml treewidth.</li></ul><p>The QuickBB algorithm is described in arXiv:1207.4109v1</p><p><strong>Keywords</strong></p><ul><li><code>time::Integer=0</code>: the number of second to run the quickbb binary for.</li><li><code>order::Symbol=:_</code>: the branching order to be used by quickbb (:random or :min_fill).</li><li><code>lb::Bool=false</code>: set if a lowerbound for the treewidth should be computed.</li><li><code>verbose::Bool=false</code>: set to true to print quickbb stdout and stderr output.</li><li><code>proc_id::Integer=0</code>: used to create uniques names of files for different processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraph.jl/blob/6ce0f5322564c1b968431a9ef6858d87f36d4efd/src/treewidth.jl#LL25-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXGraph.graph_to_cnf" href="#QXGraph.graph_to_cnf"><code>QXGraph.graph_to_cnf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">graph_to_cnf(G::lg.AbstractGraph, filename::String)</code></pre><p>Write the provided graph to a cnf file for Gogate&#39;s QuickBB binary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraph.jl/blob/6ce0f5322564c1b968431a9ef6858d87f36d4efd/src/treewidth.jl#LL11-L15">source</a></section></article><h4 id="Partial-Elimination-order"><a class="docs-heading-anchor" href="#Partial-Elimination-order">Partial Elimination order</a><a id="Partial-Elimination-order-1"></a><a class="docs-heading-anchor-permalink" href="#Partial-Elimination-order" title="Permalink"></a></h4><p>The following functions can be used to create an elimination order for a graph <span>$G$</span> with a  specified clique of <span>$G$</span> appearing at the end of the order. This is useful for finding contraction plans for tensor networks containing open indices. The algorithm and application of these functions is described further by Shutski et al in  <a href="https://arxiv.org/abs/1911.12242">this</a> paper.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraph.build_chordal_graph" href="#QXGraph.build_chordal_graph"><code>QXGraph.build_chordal_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_chordal_graph(G::LabeledGraph, π̄::Array{Symbol, 1})</code></pre><p>Return a chordal graph built from &#39;G&#39; using the elimination order &#39;π̄&#39;.</p><p>The returned graph is created from &#39;G&#39; by iterating over the vertices of &#39;G&#39;, according to  the order &#39;π̄&#39;, and for each vertex, connecting all the neighbors that appear later in the  order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraph.jl/blob/6ce0f5322564c1b968431a9ef6858d87f36d4efd/src/treewidth.jl#LL275-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXGraph.restricted_mcs" href="#QXGraph.restricted_mcs"><code>QXGraph.restricted_mcs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">restricted_mcs(H::LabeledGraph, C::Array{Symbol, 1})</code></pre><p>Return an elimination order for &#39;H&#39; with the vertices in &#39;C&#39; appearing at the end.</p><p>The algorithm is described by Shutski et al in https://arxiv.org/abs/1911.12242</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraph.jl/blob/6ce0f5322564c1b968431a9ef6858d87f36d4efd/src/treewidth.jl#LL313-L319">source</a></section></article><p>Given an elimination order <span>$\pi$</span> for a particualr graph <span>$G$</span>, the treewidth of <span>$G$</span> with  respect to the order <span>$\pi$</span> can be computed using the following function.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraph.find_treewidth_from_order" href="#QXGraph.find_treewidth_from_order"><code>QXGraph.find_treewidth_from_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_treewidth_from_order(G::LabeledGraph, π̄::Array{Symbol, 1})</code></pre><p>Return the treewidth of G with respect to the elimination order π̄.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraph.jl/blob/6ce0f5322564c1b968431a9ef6858d87f36d4efd/src/treewidth.jl#LL249-L253">source</a></section></article><h2 id="Treewidth-deletion"><a class="docs-heading-anchor" href="#Treewidth-deletion">Treewidth deletion</a><a id="Treewidth-deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Treewidth-deletion" title="Permalink"></a></h2><p>The problem of finding a select number of vertices in a graph to delete, in order to reduce the treewidth of the graph, is known as the treewidth deletion problem. A method for  solving this problem, implemented by the functions below, and it&#39;s application to tensor  network slicing is discussed by Shutski et al <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.062614">here</a>.</p><article class="docstring"><header><a class="docstring-binding" id="QXGraph.greedy_treewidth_deletion" href="#QXGraph.greedy_treewidth_deletion"><code>QXGraph.greedy_treewidth_deletion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">greedy_treewidth_deletion(G::LabeledGraph, m::Int=4;
                          score_function::Symbol=:degree, 
                          π::Array{Symbol, 1}=[])</code></pre><p>Greedily remove vertices from G with respect to minimising the chosen score function. Return the reduced graph and an array of vertices which were removed.</p><p>The intermediate elimination orders and corresponding treewidths of the intermediate graphs are also returned if an elimination order for G is provided.</p><p>The algorithm is described by Schutski et al in Phys. Rev. A 102, 062614.</p><p><strong>Keywords</strong></p><ul><li><code>score_function::Symbol=:degree</code>: function to maximise when selecting vertices to remove.                                   (:degree, :direct_treewidth)</li><li><code>elim_order:Array{Symbol, 1}=Symbol[]</code>: The elimination order for G to be used by                                          direct_treewidth score function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraph.jl/blob/6ce0f5322564c1b968431a9ef6858d87f36d4efd/src/treewidth.jl#LL164-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXGraph.direct_treewidth_score" href="#QXGraph.direct_treewidth_score"><code>QXGraph.direct_treewidth_score</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">direct_treewidth_score(G::LabeledGraph, π::Array{Symbol, 1})</code></pre><p>Return an array of integers, one for each vertex in G, indicating the change in treewidth of G, with respect to π, if that vertex is removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXGraph.jl/blob/6ce0f5322564c1b968431a9ef6858d87f36d4efd/src/treewidth.jl#LL228-L233">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../LabeledGraph/">« Labeled Graphs</a><a class="docs-footer-nextpage" href="../docs_index/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 March 2021 16:12">Thursday 25 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
